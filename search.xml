<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis数据结构解析</title>
      <link href="/2022/09/28/redis-shu-ju-jie-gou-jie-xi/"/>
      <url>/2022/09/28/redis-shu-ju-jie-gou-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h1><h2 id="1、动态字符串"><a href="#1、动态字符串" class="headerlink" title="1、动态字符串"></a>1、动态字符串</h2><p>我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是一种常用的数据结构。</p><p>不过Redis没有直接使用C语言中的字符串，因为C语言的字符串存在很多问题：</p><ul><li>获取字符串的长度需要通过运算</li><li>非二进制安全</li><li>不可修改</li></ul><p>Redis构建了一种新的字符串结构，称为简单动态字符串(Simple Dynamic String)，简称SDS。</p><p>例如，我们执行命令</p><pre class="language-none"><code class="language-none">set name jie</code></pre><p>那么Redis将在底层创建两个SDS，其中一个是包含”name”的SDS，另一个是包含”jie”的SDS.</p><p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p><p><img src="https://s2.loli.net/2022/09/28/rzHDc3b9pALsa1R.png" alt="1653984624671"></p><p>其中，一个包含”name”的SDS结构如下：</p><p><img src="https://s2.loli.net/2022/09/28/sxXyBbJKOWZ6noH.png" alt="1653984648404"></p><p>SDS之所以叫动态字符串，是因为它具备动态扩容的能力，例如一个内容为”hi”的SDS：</p><p><img src="https://s2.loli.net/2022/09/28/H9cRwgn3aQ4ljyK.png" alt="1653984787383"></p><p>假如我们要给SDS追加一段字符串”,jie”,这里会首先申请新内存空间：</p><ul><li>如果新字符串小于1M，则新空间扩展为字符串长度的两倍+1；</li><li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</li></ul><p><img src="https://s2.loli.net/2022/09/28/2Dks86PvUMGKElu.png" alt="1653984822363"></p><p><img src="https://s2.loli.net/2022/09/28/V8qKbElifDWrTsA.png" alt="1653984838306"></p><h2 id="2、intset"><a href="#2、intset" class="headerlink" title="2、intset"></a>2、intset</h2><p>IntSet是Redis中set集合的一种实现方式，基于整数数组实现，并且具备长度可变、有序等特征。</p><p>结构如下：</p><p><img src="https://s2.loli.net/2022/09/28/oVFShLdby56sYvN.png" alt="1653984923322"></p><p>其中的encoding包含三种模式，表示存储的整数大小不同：</p><p><img src="https://s2.loli.net/2022/09/28/HV4Fie9gA1jxWP5.png" alt="1653984942385"></p><p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p><p><img src="https://s2.loli.net/2022/09/28/PcCvWLSR8G2bjDZ.png" alt="1653985149557"></p><p>现在，数组汇总每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：</p><ul><li>encoding：4字节</li><li>length：4字节</li><li>contents：2字节 * 3 &#x3D; 6字节</li></ul><p><img src="https://s2.loli.net/2022/09/28/2c8zoRfhuLkJX3w.png" alt="1653985197214"></p><p>我们向其中添加一个数字：5000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。</p><p>以当前案例来说流程如下：</p><ul><li>升级编码为INTSET_ENC_INT32，每个整数占4个字节，并按照新的编码方式及元素个数扩容数组</li><li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li><li>将待添加的元素放入数组末尾</li><li>最后，将intset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li></ul><p><img src="https://s2.loli.net/2022/09/28/ji5CwOlbTgk4UfH.png" alt="1653985276621"></p><p>源码如下：</p><p><img src="https://s2.loli.net/2022/09/28/K2scBNglaMQtPJi.png" alt="1653985304075"></p><p><img src="https://s2.loli.net/2022/09/28/pDZsF839kX7V4ro.png" alt="1653985327653"></p><p><strong>小总结</strong></p><p>intset可以看做是特殊的整数数组，具备一些特点：</p><ul><li>Redis会确保intset中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用<strong>二分查找</strong>方式来查询</li></ul><h2 id="3、Dict"><a href="#3、Dict" class="headerlink" title="3、Dict"></a>3、Dict</h2><p>我们知道Redis是一个键值型(Key-Value Pair)的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正式通过Dict来实现的。</p><p>Dict由三部分组成，分别是：</p><ul><li>哈希表(DictHash Table)</li><li>哈希节点(DictEntry)</li><li>字典(Dict)</li></ul><p><img src="https://s2.loli.net/2022/09/28/MnVXzY3ty4LTwxb.png" alt="1653985396560"></p><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash计算出hash值(h)，然后利用 h &amp; sizemash 来计算元素应该存储到数组中的哪个索引位置。</p><p>例如，我们存储k1&#x3D;v1，假设k1的哈希值h&#x3D;1，则1 &amp; 3 &#x3D; 1，因此k1&#x3D;v1要存储到数组角标1位置。</p><p><img src="https://s2.loli.net/2022/09/28/mS8cVTdZW2HR6nC.png" alt="1653985497735"></p><p>Dict由三部分组成，分别是：哈希表(DictHash Table)、哈希节点(DictEntry)、字典(Dict)</p><p><img src="https://s2.loli.net/2022/09/28/i6teU83W4wku52K.png" alt="1653985570612"></p><p><img src="https://s2.loli.net/2022/09/28/7NnI2voJOqZXuyp.png" alt="1653985586543"></p><p><img src="https://s2.loli.net/2022/09/28/ujQoZmznaNLKBJs.png" alt="1653985640422"></p><h3 id="Dict的扩容"><a href="#Dict的扩容" class="headerlink" title="Dict的扩容"></a>Dict的扩容</h3><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。<br>Dict在每次新增键值对时都会检查负载因子（LoadFactor &#x3D; used&#x2F;size） ，满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的 LoadFactor &gt;&#x3D; 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；</li><li>哈希表的 LoadFactor &gt; 5 ；</li></ul><p><img src="https://s2.loli.net/2022/09/28/gnXplTN9jWdQoa8.png" alt="1653985716275"></p><p><img src="https://s2.loli.net/2022/09/28/C1VRzTqx4fQGiUv.png" alt="1653985743412"></p><h3 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h3><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ul><li><p>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</p><ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul></li><li><p>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</p></li><li><p>设置dict.rehashidx &#x3D; 0，标示开始rehash</p></li><li><p>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</p></li><li><p>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</p></li><li><p>将rehashidx赋值为-1，代表rehash结束</p></li><li><p>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</p></li></ul><p>整个过程可以描述为：</p><p><img src="https://s2.loli.net/2022/09/28/xNzYZS2gfFO1Iyi.png" alt="1653985824540"></p><p><strong>小总结</strong></p><p>Dict的结构：</p><ul><li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li><li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li></ul><p>Dict的伸缩：</p><ul><li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li><li>当LoadFactor小于0.1时，Dict收缩</li><li>扩容大小为第一个大于等于used + 1的2^n</li><li>收缩大小为第一个大于等于used 的2^n</li><li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li><li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li></ul><h2 id="3、ZipList"><a href="#3、ZipList" class="headerlink" title="3、ZipList"></a>3、ZipList</h2><p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入&#x2F;弹出操作, 并且该操作的时间复杂度为 O(1)。</p><p><img src="https://s2.loli.net/2022/09/28/nU3QbTvK18oqRgF.png" alt="1653985987327"></p><p><img src="https://s2.loli.net/2022/09/28/PjG12oyA7rLRha5.png" alt="1653986020491"></p><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>长度</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4 字节</td><td>记录整个压缩列表占用的内存字节数</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2 字节</td><td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td>entry</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1 字节</td><td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td></tr></tbody></table><h3 id="ZipListEntry"><a href="#ZipListEntry" class="headerlink" title="ZipListEntry"></a>ZipListEntry</h3><p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p><p><img src="https://s2.loli.net/2022/09/28/6UOHvNwClQBiVsq.png" alt="1653986055253"></p><ul><li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p><ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul></li><li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p></li><li><p>contents：负责保存节点的数据，可以是字符串或整数</p></li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p><h3 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h3><p>ZipListEntry中的encoding编码分为字符串和整数两种：<br>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p><table><thead><tr><th><strong>编码</strong></th><th><strong>编码长度</strong></th><th><strong>字符串大小</strong></th></tr></thead><tbody><tr><td>|00pppppp|</td><td>1 bytes</td><td>&lt;&#x3D; 63 bytes</td></tr><tr><td>|01pppppp|qqqqqqqq|</td><td>2 bytes</td><td>&lt;&#x3D; 16383 bytes</td></tr><tr><td>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td><td>5 bytes</td><td>&lt;&#x3D; 4294967295 bytes</td></tr></tbody></table><p>例如，我们要保存字符串：“ab”和 “bc”</p><p><img src="https://s2.loli.net/2022/09/28/5Us2td81YpSaQDr.png" alt="1653986172002"></p><p> ZipListEntry中的encoding编码分为字符串和整数两种：</p><ul><li>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</li></ul><table><thead><tr><th><strong>编码</strong></th><th><strong>编码长度</strong></th><th><strong>整数类型</strong></th></tr></thead><tbody><tr><td>11000000</td><td>1</td><td>int16_t（2 bytes）</td></tr><tr><td>11010000</td><td>1</td><td>int32_t（4 bytes）</td></tr><tr><td>11100000</td><td>1</td><td>int64_t（8 bytes）</td></tr><tr><td>11110000</td><td>1</td><td>24位有符整数(3 bytes)</td></tr><tr><td>11111110</td><td>1</td><td>8位有符整数(1 bytes)</td></tr><tr><td>1111xxxx</td><td>1</td><td>直接在xxxx位置保存数值，范围从0001~1101，减1后结果为实际值</td></tr></tbody></table><p><img src="https://s2.loli.net/2022/09/28/QljJH1Nptg9UZvf.png" alt="1653986282879"></p><p><img src="https://s2.loli.net/2022/09/28/F16IV9sWzCMuDjZ.png" alt="1653986217182"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p><strong>ZipList特性：</strong></p><ul><li>压缩列表的可以看做一种连续内存空间的”双向链表”</li><li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li><li>如果列表数据过多，导致链表过长，可能影响查询性能</li><li>增或删较大数据时有可能发生连续更新问题</li></ul><h2 id="4、QuickList"><a href="#4、QuickList" class="headerlink" title="4、QuickList"></a>4、QuickList</h2><blockquote><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低，怎么办？</p><p>​    答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p><p>问题2：如果我们要存储大量数据，超出了ZipList最佳的上限怎么办？</p><p>​答：我们可以创建多个ZipList来分片存储</p><p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p><p>​答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p></blockquote><p><img src="https://s2.loli.net/2022/09/28/7MjlWTy6dwv3UPZ.png" alt="1653986474927"></p><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。</p><ul><li><p>如果值为正，则代表ZipList的允许的entry个数的最大值</p></li><li><p>如果值为负，则代表ZipList的最大内存大小，分5种情况：</p><ul><li><p>-1：每个ZipList的内存占用不能超过4kb</p></li><li><p>-2：每个ZipList的内存占用不能超过8kb</p></li><li><p>-3：每个ZipList的内存占用不能超过16kb</p></li><li><p>-4：每个ZipList的内存占用不能超过32kb</p></li><li><p>-5：每个ZipList的内存占用不能超过64kb</p></li></ul></li></ul><p>​其默认值为 -2：</p><p><img src="https://s2.loli.net/2022/09/28/9v4raWces257wyC.png" alt="1653986642777"></p><p>以下是QuickList和QuickListNode的结构源码：</p><p><img src="https://s2.loli.net/2022/09/28/OEruhQxLGCBky3e.png" alt="1653986667228"></p><p>我们接下来用一段流程图来描述当前的这个结构</p><p><img src="https://s2.loli.net/2022/09/28/d3XyizUjKf57r9S.png" alt="1653986718554"></p><p><strong>总结</strong></p><p>QuickList的特点：</p><ul><li>是一个节点为ZipList的双端队列</li><li>节点采用ZipList，解决了传统链表的内存占用问题</li><li>控制了ZipList的大小，解决了连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省了内存空间</li></ul><h2 id="5、SkipList"><a href="#5、SkipList" class="headerlink" title="5、SkipList"></a>5、SkipList</h2><p>SkipList(跳表)首先是链表，但与传统链表相比有几点差异：</p><ul><li>元素按照升序排列存储</li><li>节点可能包含多个指针，指针跨度不同</li></ul><p><img src="https://s2.loli.net/2022/09/28/sgq3oMzeZf8JT1t.png" alt="1653986771309"></p><p>跳表数据结构如下所示：</p><p><img src="https://s2.loli.net/2022/09/29/iSeOR2tPWZFV1Kd.png" alt="1653986813240"></p><p>跳表总体如下图所示：</p><p><img src="https://s2.loli.net/2022/09/29/gBAIQ9uvCcwko8j.png" alt="1653986877620"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SkipList的特点：</p><ul><li>跳跃表是一个双向链表，每个节点都包含score和ele值</li><li>节点按照score值排序，score值一样则按照ele字典排序</li><li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更简单</li></ul><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><h2 id="1、RedisObject"><a href="#1、RedisObject" class="headerlink" title="1、RedisObject"></a>1、RedisObject</h2><p>Redis中的任意类型的键和值都会被封装为一个RedisObject，也叫做Redis对象。</p><blockquote><p>从Redis的使用者的角度来看，一个Redis节点包含多个database(非cluster模式下默认是16个，cluster模式下只能是一个)，而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，而value可以是多种数据类型，比如：string、list、hesh、set、sorted set等。我们可以看到，key的类型固定式string，而value的类型可能是多个。</p><p>而从Redis内部实现的角度来看，database内的这个映射关系是用一个dict来维护的。dict的key固定用一种数据结构来表达就够了，这就是动态字符串SDS。而value则比较复杂，为了在同一个dict内能够存储不同类型的value，这就需要一个通用的数据结构，这个通用的数据结构就是RedisObject。</p></blockquote><p><img src="https://s2.loli.net/2022/09/29/tzXLK7qAs3ZJHNh.png" alt="1653986956618"></p><p>Redis的编码方式</p><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><table><thead><tr><th><strong>编号</strong></th><th><strong>编码方式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>0</td><td>OBJ_ENCODING_RAW</td><td>raw编码动态字符串</td></tr><tr><td>1</td><td>OBJ_ENCODING_INT</td><td>long类型的整数的字符串</td></tr><tr><td>2</td><td>OBJ_ENCODING_HT</td><td>hash表（字典dict）</td></tr><tr><td>3</td><td>OBJ_ENCODING_ZIPMAP</td><td>已废弃</td></tr><tr><td>4</td><td>OBJ_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>5</td><td>OBJ_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>6</td><td>OBJ_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>7</td><td>OBJ_ENCODING_SKIPLIST</td><td>跳表</td></tr><tr><td>8</td><td>OBJ_ENCODING_EMBSTR</td><td>embstr的动态字符串</td></tr><tr><td>9</td><td>OBJ_ENCODING_QUICKLIST</td><td>快速列表</td></tr><tr><td>10</td><td>OBJ_ENCODING_STREAM</td><td>Stream流</td></tr></tbody></table><p>五种数据结构</p><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>编码方式</strong></th></tr></thead><tbody><tr><td>OBJ_STRING</td><td>int、embstr、raw</td></tr><tr><td>OBJ_LIST</td><td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td></tr><tr><td>OBJ_SET</td><td>intset、HT</td></tr><tr><td>OBJ_ZSET</td><td>ZipList、HT、SkipList</td></tr><tr><td>OBJ_HASH</td><td>ZipList、HT</td></tr></tbody></table><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="2、String"><a href="#2、String" class="headerlink" title="2、String"></a>2、String</h2><p>String是Redis中最常见的数据存储类型：</p><p>其基本的编码方式是RAW，基于简单动态字符串（SDS）实现的，存储上限为512mb。</p><p>如果存储的SDS长度小于44字节，则会采用<strong>EMBSTR编码</strong>，此时object head与SDS是一段连续空间，申请内存时只需要调用一次内存分配函数，效率更高。</p><h3 id="底层实现方式：动态字符串-SDS-或者-long"><a href="#底层实现方式：动态字符串-SDS-或者-long" class="headerlink" title="底层实现方式：动态字符串 SDS 或者 long"></a>底层实现方式：动态字符串 SDS 或者 long</h3><p>String的内部存储结构一般是（Simple Dynamic String，可以动态扩展内存），但是<strong>如果⼀个String类型的value的值是数字</strong>，那么Redis内部会把它转成long类型来存储，从⽽减少内存的使用。</p><p><img src="https://s2.loli.net/2022/09/29/8GOAm746HDnqW5F.png" alt="1653987103450"></p><p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用<strong>INT编码</strong>：直接将数据保存在RedisObject的<strong>ptr指针位置</strong>（刚好8字节），不再需要SDS了。</p><p><img src="https://s2.loli.net/2022/09/29/ueJKc2ELlO6ZhmT.png" alt="1653987159575"></p><p><img src="https://s2.loli.net/2022/09/29/UlFtQLgcphfe8z4.png" alt="1653987172764"></p><p><img src="https://s2.loli.net/2022/09/29/zMq63OhNVe1j74I.png" alt="1653987202522"></p><p>确切地说，String在Redis中是⽤⼀个robj来表示的。</p><p>用来表示String的robj可能编码成3种内部表⽰：OBJ_ENCODING_RAW，OBJ_ENCODING_EMBSTR，OBJ_ENCODING_INT。<br>其中前两种编码使⽤的是sds来存储，最后⼀种OBJ_ENCODING_INT编码直接把string存成了long型。</p><p>在对string进行incr, decr等操作的时候，如果它内部是<strong>OBJ_ENCODING_INT</strong>编码，那么可以直接行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串<strong>转成long型</strong>，如果能转成功，再进行加减操作。</p><p>对⼀个内部表示成<strong>long型的string</strong>执行append, setbit, getrange这些命令，针对的仍然是string的值（即⼗进制表示的字符串），而不是针对内部表⽰的long型进⾏操作。比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。⽽如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执⾏setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 原理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2022/09/27/cao-zuo-xi-tong/"/>
      <url>/2022/09/27/cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<h3 id="操作系统基础知识总结"><a href="#操作系统基础知识总结" class="headerlink" title="操作系统基础知识总结"></a>操作系统基础知识总结</h3><ol><li>进程和线程</li><li>文件系统</li></ol><ul><li>总</li><li>分</li><li>fen</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/09/22/ji-suan-ji-wang-luo/"/>
      <url>/2022/09/22/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>asfasdfasd</p><ul><li>阿斯顿发</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构1</title>
      <link href="/2022/09/22/shu-ju-jie-gou/shu-ju-jie-gou-1/"/>
      <url>/2022/09/22/shu-ju-jie-gou/shu-ju-jie-gou-1/</url>
      
        <content type="html"><![CDATA[<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>asfasdfasd</p><ul><li>阿斯顿发</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/09/22/shu-ju-jie-gou/shu-ju-jie-gou/"/>
      <url>/2022/09/22/shu-ju-jie-gou/shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h3 id="这是数据结构文章"><a href="#这是数据结构文章" class="headerlink" title="这是数据结构文章"></a>这是数据结构文章</h3><ul><li>队列</li><li>栈</li><li>二叉树</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo GitHub搭建个人博客</title>
      <link href="/2022/09/21/hexo-github-da-jian-ge-ren-bo-ke/"/>
      <url>/2022/09/21/hexo-github-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-github-搭建个人博客"><a href="#Hexo-github-搭建个人博客" class="headerlink" title="Hexo + github 搭建个人博客"></a>Hexo + github 搭建个人博客</h1><h2 id="一、-环境准备"><a href="#一、-环境准备" class="headerlink" title="一、 环境准备"></a>一、 环境准备</h2><ul><li>安装Node.js</li><li>安装Git</li></ul><h3 id="1、安装并配置Node-js"><a href="#1、安装并配置Node-js" class="headerlink" title="1、安装并配置Node.js"></a>1、安装并配置Node.js</h3><p>Hexo是基于Node.js编写的，所以需要安装Node.js和里面的npm工具。</p><p>windows：[node.js][<a href="https://nodejs.org/en/download/]%E9%80%89%E6%8B%A9LTS%E7%89%88%E6%9C%AC%E5%8D%B3%E5%8F%AF%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%88%B0%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">https://nodejs.org/en/download/]选择LTS版本即可，直接到官网下载安装</a></p><ul><li><p>Node.js(Node.js版本需要不低于10.13，建议使用Node.js 12.0 及以上版本)</p></li><li><p>Node自带npm</p><p><img src="https://pic2.zhimg.com/80/v2-e9ee44eab73fa10f1c52dd2ef267d971_1440w.jpg"></p></li></ul><h3 id="2、安装并配置Git"><a href="#2、安装并配置Git" class="headerlink" title="2、安装并配置Git"></a>2、安装并配置Git</h3><p>windows：到git官网[Download git][<a href="https://gitforwindows.org/]%E4%B8%8A%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%90%8E%E5%8D%95%E5%87%BB%E5%8F%B3%E9%94%AE%E4%BC%9A%E6%9C%89%E4%B8%80%E4%B8%AAGit">https://gitforwindows.org/]上下载，下载后单击右键会有一个Git</a> Bash的命令行工具，以后通过这个工具来使用git</p><h3 id="3、版本检查"><a href="#3、版本检查" class="headerlink" title="3、版本检查"></a>3、版本检查</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> <span class="token parameter variable">-v</span>  <span class="token comment">#检查node版本</span><span class="token function">npm</span> <span class="token parameter variable">-v</span> <span class="token comment">#检查npm版本</span><span class="token function">git</span> <span class="token parameter variable">--version</span> <span class="token comment">#检查git版本</span></code></pre><p>如果出现对应的版本号，那么表示本地环境搭建成功</p><p><img src="https://pic2.zhimg.com/80/v2-d7dd3c51e2cc7eec354caca723351961_1440w.jpg"></p><h2 id="二、Hexo搭建及基本配置"><a href="#二、Hexo搭建及基本配置" class="headerlink" title="二、Hexo搭建及基本配置"></a>二、Hexo搭建及基本配置</h2><h3 id="1、GitHub注册"><a href="#1、GitHub注册" class="headerlink" title="1、GitHub注册"></a>1、GitHub注册</h3><ul><li><p>进入GitHub官网，点击注册</p></li><li><p>注册用户名，进行绑定邮箱等操作</p></li><li><p>在任一文件夹中，点击鼠标右键，点击 <code>Git Bash Here</code></p></li><li><p>依次输入：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"你的GitHub用户名"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"你的GitHub邮箱"</span></code></pre><p><img src="https://pic4.zhimg.com/80/v2-11e02793f81bf7b5bc1d31952828b9f7_1440w.jpg"></p></li></ul><p>可以使用以下两条命令，检查一下你是否输入正确</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.name<span class="token function">git</span> config user.email</code></pre><ul><li><p>输入以下命令，生成SSH秘钥：</p><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"github邮箱"</span></code></pre></li><li><p>然后一路回车，创建SSH秘钥。这个时候它会告诉你已经生成 .ssh 的文件夹，在电脑中找到这个文件夹</p><blockquote><p>ssh:简单来讲，就是一个秘钥。其中，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看；<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p></blockquote></li><li><p>进入下面路径</p><pre class="language-none"><code class="language-none">.ssh生成路径：C:\Users\用户名\.ssh</code></pre><p><img src="https://pic1.zhimg.com/80/v2-f1480143361c61191fa906f04c3dea70_1440w.jpg"></p></li><li><p>用记事本或Notepad++打开 <code>id_rsa.pub</code>文件，复制里面的内容</p></li><li><p>登录GitHub，进入<code>setting</code>。</p><p><img src="https://pic3.zhimg.com/80/v2-43404d4f1c74e651fd6bf9ec3938ca56_1440w.jpg"></p></li><li><p>选择左边的 <code>SSH and GPG Keys</code>选项，进行添加加密</p><p><img src="https://pic3.zhimg.com/80/v2-c7b7637f00b0c9044dd48bd6b6c56e12_1440w.jpg"></p></li><li><p>点击<code>New SSH Key</code>进行添加</p><p><img src="https://pic2.zhimg.com/80/v2-647a61b616a85e348b6e6e2cd1210a41_1440w.jpg"></p></li><li><p>Title自己取名字，把刚才复制的秘钥粘贴到Key中，然后点击<code>Add SSH Key</code>添加完成。</p></li></ul><p><img src="https://pic4.zhimg.com/v2-c15dc054e5c877f0dfa66fc4de8c4c5b_r.jpg"></p><ul><li><p>测定ssh是否绑定成功</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token parameter variable">-T</span> git@github.com</code></pre><p>出现<code>Are you sure……</code>的时候输入yes回车。</p><p>最后显示<code>You&#39;ve successfully……</code>的时候表示连接成功。</p></li></ul><h3 id="2、创建GitHub-Pages仓库"><a href="#2、创建GitHub-Pages仓库" class="headerlink" title="2、创建GitHub Pages仓库"></a>2、创建GitHub Pages仓库</h3><blockquote><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。可以把它理解为动态网站的主机。</p></blockquote><ul><li><p>打开GitHub，点击右上角加号，然后点击<code>New repository</code>新建GitHub Pages仓库。</p><p><img src="https://pic2.zhimg.com/80/v2-3369168e1161c6ce7b1d87ceb6ce388d_1440w.jpg"></p></li><li><p>在Repository name中输入：<code>用户名.github.io</code></p></li><li><p><code>Description</code><strong>选填</strong>。</p></li><li><p><strong>勾选</strong><code>Initialize this repository with a README</code></p></li><li><p>填好后点击<code>Create repository</code>。创建后默认启用HTTPS。</p></li><li><p><strong>博客的地址为:</strong><code>https://用户名.github.io</code></p></li></ul><p><img src="https://pic4.zhimg.com/80/v2-7ca628d66faba34720d562f5c5517747_1440w.jpg"></p><ul><li>这样GitHub仓库就创建完成了</li></ul><p><img src="https://pic1.zhimg.com/80/v2-9accac61be6b819a4890f32f9ba91e78_1440w.jpg"></p><h3 id="3、安装Hexo博客"><a href="#3、安装Hexo博客" class="headerlink" title="3、安装Hexo博客"></a>3、安装Hexo博客</h3><ul><li><p>首先在电脑磁盘*(自己选择想要存放博客程序，文件以及后续博客美化等文件的磁盘)*中新建一个文件夹，我这里命名<code>Blog-Hexo</code>，<strong>路径中最好不要存在中文</strong>。</p></li><li><p>新建后打开此文件，右键打开<code>Git Bash Here</code>进入git命令窗口 <em>(之前打开的可以关闭了)</em></p></li><li><p><strong>注意：一定要在<code>Blog-Hexo</code>文件夹中打开命令行</strong></p></li><li><p>使用npm安装Hexo博客程序。输入：</p></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli</code></pre><p><img src="https://pic1.zhimg.com/80/v2-d7ce8dfd9e72326b510dce9ab866a8ac_1440w.jpg"></p><ul><li>初始化和安装所需的组件。输入：</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">hexo init</code></pre><p><img src="https://pic2.zhimg.com/80/v2-861490b724ad21c95677dba52750d90d_1440w.jpg"></p><ul><li>这时候我们Blog-Hexo文件夹中就会生成一些目录文件：</li></ul><blockquote><p>node_modules：依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章和图片等等<br>themes：主题文件夹，后面美化博客时会用到<br><strong>_config.yml：博客的网站配置文件</strong>(太重要了！！！)</p></blockquote><ul><li>Hexo博客初始化就完成了，下面我们启用本地服务器进行本地预览。继续在命令行输入：</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">hexo g  <span class="token comment">#生成静态页面</span></code></pre><p><img src="https://pic3.zhimg.com/80/v2-137b70036cad0d9e65c240568526f9b6_1440w.jpg"></p><pre class="language-bash" data-language="bash"><code class="language-bash">hexo s   <span class="token comment">#启动预览</span></code></pre><p>一会命令行将会看到<code>http://localhost:4000</code>，现在就可以使用浏览器本地预览了，注意预览时<strong>不要</strong>按到<strong>Ctrl+C</strong>停止预览。</p><p><img src="https://pic4.zhimg.com/80/v2-b8d52ec38bea9ffadc41d00ab6926307_1440w.jpg"></p><p>打开浏览器，在地址栏中输入：</p><pre class="language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:4000</code></pre><p>此时就可以看到创建的个人博客主题了，这是Hexo的默认界面</p><p><img src="https://pic2.zhimg.com/80/v2-effd11686c4e083c4a3b1df649a51731_1440w.jpg"></p><p>那么，恭喜！本地博客安装成功了！</p><h3 id="4、上传部署Github"><a href="#4、上传部署Github" class="headerlink" title="4、上传部署Github"></a>4、上传部署Github</h3><p>前面我们只能通过4000端口进行预览，只能自己看到，别人是看不到的，所以我们做这一步的目的是：使其能够通过域名或者网站访问。</p><ul><li>需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</li></ul><p>​        首先<code>Ctrl+c</code>断开本地预览，接着输入：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span></code></pre><p><img src="https://pic2.zhimg.com/80/v2-dea692904c72ffd4776ed4184ce56d5d_1440w.jpg"></p><ul><li>在博客文件夹中打开网站配置文件_config.yml。（如果电脑上有写代码的编辑器就用编辑器打开，没有就用记事本打开。）</li></ul><p>​找到文件末尾，在此处加上下面的代码：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repository</span><span class="token punctuation">:</span> git@github.com<span class="token punctuation">:</span>用户名/用户名.github.io.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master</code></pre><p><img src="https://pic3.zhimg.com/80/v2-b56928ba2617c4e530c115c11c5b8e92_1440w.jpg"></p><ul><li>然后在命令行依次输入：</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">hexo g <span class="token comment">#即hexo generate，生成静态文章</span>hexo d <span class="token comment">#即hexo deploy，部署文章</span></code></pre><ul><li>上传成功后我们就可以使用网址进行访问了。网址为：</li></ul><pre class="language-none"><code class="language-none">https:&#x2F;&#x2F;你的用户名.github.io</code></pre><p>那么，到这里搭建及美化Hexo的第一期教程就结束咯。</p><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo new <span class="token string">"name"</span>        <span class="token comment">#新建文章</span>hexo new page <span class="token string">"name"</span>   <span class="token comment">#新建页面</span>hexo g                 <span class="token comment">#生成页面</span>hexo d                 <span class="token comment">#部署</span>hexo g <span class="token parameter variable">-d</span>              <span class="token comment">#生成页面并部署</span>hexo s                 <span class="token comment">#本地预览</span>hexo clean             <span class="token comment">#清除缓存和已生成的静态文件</span></code></pre><p><strong>发布文章的时候用</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">hexo clean        <span class="token comment">#清除缓存和已生成的静态文件</span>hexo g            <span class="token comment">#生成页面</span>hexo s            <span class="token comment">#本地预览</span>hexo d            <span class="token comment">#部署</span></code></pre><blockquote><p><code>hexo clean</code> 和 <code>hexo s</code>没必要每次都用，但是<code>hexo g</code> 和 <code>hexo d</code> 每次部署都要用到。<br>部署到博客界面可能很慢，多刷新或耐心等待下~</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub搭建个人博客</title>
      <link href="/2022/09/21/hexo-github-da-jian-ge-ren-bo-ke/"/>
      <url>/2022/09/21/hexo-github-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-github-搭建个人博客"><a href="#Hexo-github-搭建个人博客" class="headerlink" title="Hexo + github 搭建个人博客"></a>Hexo + github 搭建个人博客</h1><h2 id="一、-环境准备"><a href="#一、-环境准备" class="headerlink" title="一、 环境准备"></a>一、 环境准备</h2><ul><li>安装Node.js</li><li>安装Git</li></ul><h3 id="1、安装并配置Node-js"><a href="#1、安装并配置Node-js" class="headerlink" title="1、安装并配置Node.js"></a>1、安装并配置Node.js</h3><p>Hexo是基于Node.js编写的，所以需要安装Node.js和里面的npm工具。</p><p>windows：<a href="https://nodejs.org/en/download/">node.js</a>选择LTS版本即可，直接到官网下载安装</p><ul><li><p>Node.js(Node.js版本需要不低于10.13，建议使用Node.js 12.0 及以上版本)</p></li><li><p>Node自带npm</p><p><img src="https://pic2.zhimg.com/80/v2-e9ee44eab73fa10f1c52dd2ef267d971_1440w.jpg"></p></li></ul><h3 id="2、安装并配置Git"><a href="#2、安装并配置Git" class="headerlink" title="2、安装并配置Git"></a>2、安装并配置Git</h3><p>windows：到git官网<a href="https://gitforwindows.org/">Download git</a>上下载，下载后单击右键会有一个Git Bash的命令行工具，以后通过这个工具来使用git</p><h3 id="3、版本检查"><a href="#3、版本检查" class="headerlink" title="3、版本检查"></a>3、版本检查</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">node</span> <span class="token parameter variable">-v</span>  <span class="token comment">#检查node版本</span><span class="token function">npm</span> <span class="token parameter variable">-v</span> <span class="token comment">#检查npm版本</span><span class="token function">git</span> <span class="token parameter variable">--version</span> <span class="token comment">#检查git版本</span></code></pre><p>如果出现对应的版本号，那么表示本地环境搭建成功</p><p><img src="https://pic2.zhimg.com/80/v2-d7dd3c51e2cc7eec354caca723351961_1440w.jpg"></p><h2 id="二、Hexo搭建及基本配置"><a href="#二、Hexo搭建及基本配置" class="headerlink" title="二、Hexo搭建及基本配置"></a>二、Hexo搭建及基本配置</h2><h3 id="1、GitHub注册"><a href="#1、GitHub注册" class="headerlink" title="1、GitHub注册"></a>1、GitHub注册</h3><ul><li><p>进入GitHub官网，点击注册</p></li><li><p>注册用户名，进行绑定邮箱等操作</p></li><li><p>在任一文件夹中，点击鼠标右键，点击 <code>Git Bash Here</code></p></li><li><p>依次输入：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"你的GitHub用户名"</span><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"你的GitHub邮箱"</span></code></pre><p><img src="https://pic4.zhimg.com/80/v2-11e02793f81bf7b5bc1d31952828b9f7_1440w.jpg"></p></li></ul><p>可以使用以下两条命令，检查一下你是否输入正确</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> config user.name<span class="token function">git</span> config user.email</code></pre><ul><li><p>输入以下命令，生成SSH秘钥：</p><pre class="language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"github邮箱"</span></code></pre></li><li><p>然后一路回车，创建SSH秘钥。这个时候它会告诉你已经生成 .ssh 的文件夹，在电脑中找到这个文件夹</p><blockquote><p>ssh:简单来讲，就是一个秘钥。其中，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看；<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p></blockquote></li><li><p>进入下面路径</p><pre class="language-none"><code class="language-none">.ssh生成路径：C:\Users\用户名\.ssh</code></pre><p><img src="https://pic1.zhimg.com/80/v2-f1480143361c61191fa906f04c3dea70_1440w.jpg"></p></li><li><p>用记事本或Notepad++打开 <code>id_rsa.pub</code>文件，复制里面的内容</p></li><li><p>登录GitHub，进入<code>setting</code>。</p><p><img src="https://pic3.zhimg.com/80/v2-43404d4f1c74e651fd6bf9ec3938ca56_1440w.jpg"></p></li><li><p>选择左边的 <code>SSH and GPG Keys</code>选项，进行添加加密</p><p><img src="https://pic3.zhimg.com/80/v2-c7b7637f00b0c9044dd48bd6b6c56e12_1440w.jpg"></p></li><li><p>点击<code>New SSH Key</code>进行添加</p><p><img src="https://pic2.zhimg.com/80/v2-647a61b616a85e348b6e6e2cd1210a41_1440w.jpg"></p></li><li><p>Title自己取名字，把刚才复制的秘钥粘贴到Key中，然后点击<code>Add SSH Key</code>添加完成。</p></li></ul><p><img src="https://pic4.zhimg.com/v2-c15dc054e5c877f0dfa66fc4de8c4c5b_r.jpg"></p><ul><li><p>测定ssh是否绑定成功</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token parameter variable">-T</span> git@github.com</code></pre><p>出现<code>Are you sure……</code>的时候输入yes回车。</p><p>最后显示<code>You&#39;ve successfully……</code>的时候表示连接成功。</p></li></ul><h3 id="2、创建GitHub-Pages仓库"><a href="#2、创建GitHub-Pages仓库" class="headerlink" title="2、创建GitHub Pages仓库"></a>2、创建GitHub Pages仓库</h3><blockquote><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。可以把它理解为动态网站的主机。</p></blockquote><ul><li><p>打开GitHub，点击右上角加号，然后点击<code>New repository</code>新建GitHub Pages仓库。</p><p><img src="https://pic2.zhimg.com/80/v2-3369168e1161c6ce7b1d87ceb6ce388d_1440w.jpg"></p></li><li><p>在Repository name中输入：<code>用户名.github.io</code></p></li><li><p><code>Description</code><strong>选填</strong>。</p></li><li><p><strong>勾选</strong><code>Initialize this repository with a README</code></p></li><li><p>填好后点击<code>Create repository</code>。创建后默认启用HTTPS。</p></li><li><p><strong>博客的地址为:</strong><code>https://用户名.github.io</code></p></li></ul><p><img src="https://pic4.zhimg.com/80/v2-7ca628d66faba34720d562f5c5517747_1440w.jpg"></p><ul><li>这样GitHub仓库就创建完成了</li></ul><p><img src="https://pic1.zhimg.com/80/v2-9accac61be6b819a4890f32f9ba91e78_1440w.jpg"></p><h3 id="3、安装Hexo博客"><a href="#3、安装Hexo博客" class="headerlink" title="3、安装Hexo博客"></a>3、安装Hexo博客</h3><ul><li><p>首先在电脑磁盘*(自己选择想要存放博客程序，文件以及后续博客美化等文件的磁盘)*中新建一个文件夹，我这里命名<code>Blog-Hexo</code>，<strong>路径中最好不要存在中文</strong>。</p></li><li><p>新建后打开此文件，右键打开<code>Git Bash Here</code>进入git命令窗口 <em>(之前打开的可以关闭了)</em></p></li><li><p><strong>注意：一定要在<code>Blog-Hexo</code>文件夹中打开命令行</strong></p></li><li><p>使用npm安装Hexo博客程序。输入：</p></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli</code></pre><p><img src="https://pic1.zhimg.com/80/v2-d7ce8dfd9e72326b510dce9ab866a8ac_1440w.jpg"></p><ul><li>初始化和安装所需的组件。输入：</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">hexo init</code></pre><p><img src="https://pic2.zhimg.com/80/v2-861490b724ad21c95677dba52750d90d_1440w.jpg"></p><ul><li>这时候我们Blog-Hexo文件夹中就会生成一些目录文件：</li></ul><blockquote><p>node_modules：依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章和图片等等<br>themes：主题文件夹，后面美化博客时会用到<br><strong>_config.yml：博客的网站配置文件</strong>(太重要了！！！)</p></blockquote><ul><li>Hexo博客初始化就完成了，下面我们启用本地服务器进行本地预览。继续在命令行输入：</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">hexo g  <span class="token comment">#生成静态页面</span></code></pre><p><img src="https://pic3.zhimg.com/80/v2-137b70036cad0d9e65c240568526f9b6_1440w.jpg"></p><pre class="language-bash" data-language="bash"><code class="language-bash">hexo s   <span class="token comment">#启动预览</span></code></pre><p>一会命令行将会看到<code>http://localhost:4000</code>，现在就可以使用浏览器本地预览了，注意预览时<strong>不要</strong>按到<strong>Ctrl+C</strong>停止预览。</p><p><img src="https://pic4.zhimg.com/80/v2-b8d52ec38bea9ffadc41d00ab6926307_1440w.jpg"></p><p>打开浏览器，在地址栏中输入：</p><pre class="language-none"><code class="language-none">http:&#x2F;&#x2F;localhost:4000</code></pre><p>此时就可以看到创建的个人博客主题了，这是Hexo的默认界面</p><p><img src="https://pic2.zhimg.com/80/v2-effd11686c4e083c4a3b1df649a51731_1440w.jpg"></p><p>那么，恭喜！本地博客安装成功了！</p><h3 id="4、上传部署Github"><a href="#4、上传部署Github" class="headerlink" title="4、上传部署Github"></a>4、上传部署Github</h3><p>前面我们只能通过4000端口进行预览，只能自己看到，别人是看不到的，所以我们做这一步的目的是：使其能够通过域名或者网站访问。</p><ul><li>需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</li></ul><p>​        首先<code>Ctrl+c</code>断开本地预览，接着输入：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span></code></pre><p><img src="https://pic2.zhimg.com/80/v2-dea692904c72ffd4776ed4184ce56d5d_1440w.jpg"></p><ul><li>在博客文件夹中打开网站配置文件_config.yml。（如果电脑上有写代码的编辑器就用编辑器打开，没有就用记事本打开。）</li></ul><p>​找到文件末尾，在此处加上下面的代码：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">deploy</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> git  <span class="token key atrule">repository</span><span class="token punctuation">:</span> git@github.com<span class="token punctuation">:</span>用户名/用户名.github.io.git  <span class="token key atrule">branch</span><span class="token punctuation">:</span> master</code></pre><p><img src="https://pic3.zhimg.com/80/v2-b56928ba2617c4e530c115c11c5b8e92_1440w.jpg"></p><ul><li>然后在命令行依次输入：</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">hexo g <span class="token comment">#即hexo generate，生成静态文章</span>hexo d <span class="token comment">#即hexo deploy，部署文章</span></code></pre><ul><li>上传成功后我们就可以使用网址进行访问了。网址为：</li></ul><pre class="language-none"><code class="language-none">https:&#x2F;&#x2F;你的用户名.github.io</code></pre><p>那么，到这里搭建及美化Hexo的第一期教程就结束咯。</p><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><pre class="language-bash" data-language="bash"><code class="language-bash">hexo new <span class="token string">"name"</span>        <span class="token comment">#新建文章</span>hexo new page <span class="token string">"name"</span>   <span class="token comment">#新建页面</span>hexo g                 <span class="token comment">#生成页面</span>hexo d                 <span class="token comment">#部署</span>hexo g <span class="token parameter variable">-d</span>              <span class="token comment">#生成页面并部署</span>hexo s                 <span class="token comment">#本地预览</span>hexo clean             <span class="token comment">#清除缓存和已生成的静态文件</span></code></pre><p><strong>发布文章的时候用</strong></p><pre class="language-bash" data-language="bash"><code class="language-bash">hexo clean        <span class="token comment">#清除缓存和已生成的静态文件</span>hexo g            <span class="token comment">#生成页面</span>hexo s            <span class="token comment">#本地预览</span>hexo d            <span class="token comment">#部署</span></code></pre><blockquote><p><code>hexo clean</code> 和 <code>hexo s</code>没必要每次都用，但是<code>hexo g</code> 和 <code>hexo d</code> 每次部署都要用到。<br>部署到博客界面可能很慢，多刷新或耐心等待下~</p></blockquote><h2 id="主题及问题总结"><a href="#主题及问题总结" class="headerlink" title="主题及问题总结"></a>主题及问题总结</h2><blockquote><p>本人使用的hexo主题为<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>，效果图如下：</p></blockquote><p><img src="https://camo.githubusercontent.com/ca91ff24a662fc02f64cfed3446fadc7d84dade01a698ebe3dd7b3710926489a/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d312e706e67"></p><p><img src="https://camo.githubusercontent.com/cc39895742d9eb7a90d25b8f4935be41a4feffc034eb1e3f665316699634e5cc/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d322e706e67"></p><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><h3 id="1、代码高亮"><a href="#1、代码高亮" class="headerlink" title="1、代码高亮"></a>1、代码高亮</h3><blockquote><p>默认的代码高亮很丑，因此主题作者给了一种解决方案，对比如下图所示</p></blockquote><ul><li>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>&#123;</code> 和 <code>&#125;</code> 的转义字符。</li><li>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</li></ul><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prismjs</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span></code></pre><p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p><ul><li><strong>完成配置后一定要注意先清除缓存，然后再启动，否则配置修改可能不生效</strong>，命令如下</li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">hexo clean   <span class="token comment">#清除缓存</span>hexo s       <span class="token comment">#启动预览</span></code></pre><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20210624_38607c6e-d500-11eb-8d30-00163e068ecd.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2022/09/20/post/"/>
      <url>/2022/09/20/post/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进步 </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>post</title>
      <link href="/2022/09/20/post-fu-ben/"/>
      <url>/2022/09/20/post-fu-ben/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2022/09/20/hello-world/"/>
      <url>/2022/09/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><!--- more ---><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> HelloWorld </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 进步 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
